function [coh J] = xtp_coherencyc(timeseries, cohPairListID, cparams, EMGcutoff)
% This function calls chronux coherencyc for each pair of leads specified.
% Input dataset is a timeseries in the form generated by XTP:
%   - metadata field is a structure array with one cell per epoch
%   - data field is a cell array with one cell per epoch, each cell contains
%   an SxL matrix where S is the number of samples and L is the number of
%   electrode leads.
%
% cohPairListID identifies an element in the global variable
% XTP_COHERENCY_PAIRS that contains a Px2 matrix, each row indicating a
% pair of leads on which to calculate coherency. The numbers in the rows
% correspond to the column number of the lead in the input dataset.
% 
% cparams is an optional input for passing to the chronux routine - if none
% is specified the global chronux defaults (XTP_CHRONUX_PARAMS) will be
% used.
%
% output variable will contain a structure with information about when &
% how it was generated, metadata from the timeseries and chronux output.
%
% v2.0: function can also output fourier transforms (J) of the channels used
% in the cohPairList, these are in the form of a Px2 cell array with one
% row for each cohPair and one cell for each channel in the cohPair. 
%
%EXAMPLE: [coh J] = xtp_coherencyc(timeseries, coherencyPairListID, cparams)
%
% Change Control:
% Ver   Date        Person      Change
% ----- ----------- ----------- -------------------------------------------
% 1.0   01/05/09    S.Williams  Created.
% 1.1   01/06/09    S.Williams  minor debugging
% 1.2   01/12/09    S.Williams  changed name of output 'coherencyinfo'
%                               field to 'funcinfo', added datatype 
% 1.3	01/14/09    S.Williams  changed funcinfo to info, changed datatype
%                               to all caps, added info.source field for 
%                               compatibility with xtp_plotSpectra, changed
%                               data field to output field
% 1.4   01/25/09    S. Williams fixed call to coherencyc in the case of
%                               jackknife error bars. updated helptext to
%                               reflect change in input & output variables.
%                               updated .info field to separate generatedby
%                               and version.
% 1.5   01/27/09    S. Williams interactively request coherency pair list
%                               id if it is not given in command line.
% 1.6   03/19/09    S. Williams save a copy of the cohpairs and the headbox
%                               labels in .info.
% 1.7   03/20/09    S. Williams remove reference to HBmontageID
% 1.8   04/10/09    S. Williams reference XTP_HB_MONTAGES instead of
%                               XTP_HEADBOXES
% 1.9   06/25/09    S. Williams respect EMG ratings if provided
% 2.0   04/03/10    S.Williams  call xtp_coherencycJ and output fft J
%                               (only if err = 2 since coherencyc
%                               uses nargout to validate command line with
%                               respect to desired error checking).
%       04/04/10    S. Williams Updated with respect to output of FFT 
% 2.1   04/10/10    S. Williams Added metadata to FFT output
% ***DON'T FORGET TO UPDATE VERSION NUMBER IN CODE BELOW.***

funcname = 'xtp_coherencyc.m';
version = 'v2.1';

global XTP_GLOBAL_PARAMS XTP_CHRONUX_PARAMS XTP_COHERENCY_PAIRS XTP_HB_MONTAGES

if nargin < 4
    if isfield(XTP_GLOBAL_PARAMS , 'EMGcutoff')
        EMGcutoff = XTP_GLOBAL_PARAMS.EMGcutoff;
    else
        EMGcutoff = 1;
    end
    if nargin < 3
        cparams = XTP_CHRONUX_PARAMS;
        if nargin < 2
            fprintf(1, 'Please specify a coherency pair list:\n');
            for cpl = 1:length(XTP_COHERENCY_PAIRS)
                fprintf(1,' - Enter %d for %s (Headbox = %s)\n', cpl, XTP_COHERENCY_PAIRS(cpl).name, XTP_HB_MONTAGES(XTP_COHERENCY_PAIRS(cpl).HBmontageID).name);
            end
            cohPairListID = input('Your choice: ');
        end
    end
end

coh.info.datatype = 'COHERENCY';
coh.info.source = inputname(1);
coh.info.generatedBy = funcname;
coh.info.version = version;
coh.info.rundate = clock;
coh.info.cparams = cparams;
coh.info.cohPairListID = cohPairListID;

hbmid = XTP_COHERENCY_PAIRS(cohPairListID).HBmontageID;
coh.info.channelNames = XTP_HB_MONTAGES(hbmid).channelNames;

cohpairs = XTP_COHERENCY_PAIRS(cohPairListID).pairs;
coh.info.cohpairs = cohpairs;
numCohpairs = size(cohpairs,1);

coh.info.EMGcutoff = EMGcutoff;
coh.metadata = timeseries.metadata;

numtrials = size(timeseries.data, 2);
[numsamples numleads] = size(timeseries.data{1});   %assumes all epochs are the same length!!
datacube = zeros(numsamples,numtrials,numleads);
for t=1:numtrials
    datacube(:,t,:) = timeseries.data{t};
end

% check for EMG ratings
if isfield(timeseries.metadata, 'EMGratings')
    [EMGratings{1:numtrials,1}] = timeseries.metadata.EMGratings;    
    EMGratings = cell2mat(EMGratings);          % nEpochs x nChannels
    goodEpochsChannels = (EMGratings <= EMGcutoff); % this is a binary logical matrix of what's good
end

coh.output = cell(1,numCohpairs);
fprintf(1,'Calculating coherence between:\n');
for p=1:numCohpairs
    lead1 = cohpairs(p,1);
    lead2 = cohpairs(p,2);
    fprintf(1, 'pair %d of %d...\n',p,numCohpairs);

    if isfield(timeseries.metadata, 'EMGratings')
        goodEpochs = (goodEpochsChannels(:,lead1) & goodEpochsChannels(:,lead2));  % This is a list of indexes of viable epochs (those that are good for both channels in the cohpair)
        goodDatacube = datacube(:,goodEpochs,:);
        fprintf(1,'\t(using %d epochs)\n',sum(goodEpochs));
    else
        goodDatacube = datacube;
    end

    % coherencyc has different output variables depending on the choice of
    % errorbar calculation
    if ~isempty(goodDatacube)   %% probably should put empty fields in the ELSE condition so as to keep plotter from failing
        switch cparams.err(1)
            case 1
                    [coh.output{p}.C coh.output{p}.phi coh.output{p}.S12 coh.output{p}.S1 coh.output{p}.S2 coh.output{p}.f coh.output{p}.confC coh.output{p}.phistd] = coherencyc(goodDatacube(:,:,lead1), goodDatacube(:,:,lead2), cparams);
            case 2
                    [coh.output{p}.C coh.output{p}.phi coh.output{p}.S12 coh.output{p}.S1 coh.output{p}.S2 coh.output{p}.f coh.output{p}.confC coh.output{p}.phistd coh.output{p}.Cerr, J.output{p,1}, J.output{p,2}] = xtp_coherencycJ(goodDatacube(:,:,lead1), goodDatacube(:,:,lead2), cparams);
            otherwise
                    [coh.output{p}.C coh.output{p}.phi coh.output{p}.S12 coh.output{p}.S1 coh.output{p}.S2 coh.output{p}.f] = coherencyc(goodDatacube(:,:,lead1), goodDatacube(:,:,lead2), cparams);
        end
    end
end

J.info = coh.info;
J.info.f = coh.output{1}.f;
J.metadata = timeseries.metadata;
J.info.datatype = 'COH FFT';

